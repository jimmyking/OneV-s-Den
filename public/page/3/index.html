
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>OneV's Den</title>
	<meta name="author" content="onevcat">

	
	<meta name="description" content="Jun 30th, 2012 能工巧匠集 WWDC 2012 Session笔记——205 Introducing Collection Views 这是博主的WWDC2012笔记系列中的一篇，完整的笔记列表可以参看这里。如果您是首次来到本站，也许您会有兴趣通过RSS， &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="OneV's Den" type="application/atom+xml">
	
	<link rel="canonical" href="http://onevcat.com/page/3/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<script type="text/javascript">var switchTo5x=false;</script>
<script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
<script type="text/javascript">stLight.options({publisher: "496dac80-40ba-487b-b557-af2d3629eb28", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='http://www.gravatar.com/avatar/" + MD5("onev@onevcat.com") + "?s=160' alt='Profile Picture' style='width: 160px;'");
	</script>
</div>
<h1><a href="/">OneV's Den</a></h1>
<p class="subtitle">上善若水，人淡如菊</p>
<p class="subtitle">iOS/Mac，Unity3D开发者，现就职于日本创意公司Kayac，正在修行，探求创意之源</p>
<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/aboutme/">关于我</a></li>
  <li><a href="/blog/archives">全部文章</a></li>
  <li><a href="/showcase">我的项目</a></li>
  <li><a href="http://pomo.onevcat.com">	Pomo Do - 番茄工作法工具</a></li>
  <li><a href="http://ourmoney.onevcat.com">	Our Money - 多人同步记账</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/onevcat" title="Sina Weibo">Weibo</a>
		
		
		<a class="facebook" href="http://www.facebook.com/onevcat" title="Facebook">Facebook</a>
		
		
		<a class="google" href="https://plus.google.com/107108267983477358170" rel="author" title="Google+">Google+</a>
		
		
		<a class="twitter" href="http://twitter.com/onevcat" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/onevcat" title="GitHub">GitHub</a>
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
<a href="http://eepurl.com/wNSkj"><script type="text/javascript" language="JavaScript" src="http://onevcat.us5.list-manage.com/subscriber-count?b=32&u=3244d6df-04b2-4c3b-bfb2-06ac1dd40a00&id=cfde66e507"></script></a>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-06-30T00:00:00+09:00" data-updated="true" itemprop="datePublished">Jun 30<span>th</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/category/neng-gong-qiao-jiang-ji/'>能工巧匠集</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/2012/06/introducing-collection-views/" itemprop="url">WWDC 2012 Session笔记——205 Introducing Collection Views</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><!--:zh--><p style="text-align: justify;"><a href="http://www.onevcat.com/wp-content/uploads/2012/06/QQ20120630-7.png"><img class="aligncenter size-full wp-image-943" title="QQ20120630-7" src="http://www.onevcat.com/wp-content/uploads/2012/06/QQ20120630-7.png" alt="" width="732" height="113" data-pinit="registered" /></a></p>
<p style="text-align: justify;">这是博主的WWDC2012笔记系列中的一篇，完整的笔记列表可以参看<a href="http://www.onevcat.com/tag/wwdc/">这里</a>。如果您是首次来到本站，也许您会有兴趣通过<a href="http://www.onevcat.com/feed">RSS</a>，或者通过页面下方的邮件订阅的方式订阅本站。</p>
<p style="text-align: justify;">在之前的<a href="http://www.onevcat.com/2012/06/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84ios6-sdk%E6%96%B0%E7%89%B9%E6%80%A7/">iOS6 SDK新特性前瞻</a>中我曾经提到过UICollectionView，当时只把CollectionView当作是一个现在已有的开源GridView，仔细研究了下WWDC2012相关的Session后发现并不是那么简单。Apple这次真的给广大开发者带来了一个非常powerful的view，其强大程度可以说远超UITableView。接下来的这篇笔记将对应Session 205，作为使用UICollectionView的入门，之后还将完成一篇关于深入使用UICollectionView以及相应的Layout的笔记。</p>
<p style="text-align: justify;">废话到此，正式开始。</p></p>

<p><h3 style="text-align: justify;">什么是UICollectionView</h3>
<p style="text-align: justify;">UICollectionView是一种新的数据展示方式，简单来说可以把他理解成多列的UITableView(请一定注意这是UICollectionView的最最简单的形式)。如果你用过iBooks的话，可能你还对书架布局有一定印象：一个虚拟书架上放着你下载和购买的各类图书，整齐排列。其实这就是一个UICollectionView的表现形式，或者iPad的iOS6中的原生时钟应用中的各个时钟，也是UICollectionView的最简单的一个布局，如图：</p>
<p style="text-align: justify;"><!--:-->
		
		<a href="/2012/06/introducing-collection-views/" class="more-link">继续阅读</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-06-24T00:00:00+09:00" data-updated="true" itemprop="datePublished">Jun 24<span>th</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/category/neng-gong-qiao-jiang-ji/'>能工巧匠集</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/2012/06/modern-objective-c/" itemprop="url">WWDC 2012 Session笔记——405 Modern Objective-C</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><!--:zh--><a href="http://www.onevcat.com/wp-content/uploads/2012/06/QQ20120624-1.png"><img class="aligncenter size-full wp-image-912" title="QQ20120624-1" src="http://www.onevcat.com/wp-content/uploads/2012/06/QQ20120624-1.png" alt="" width="600" height="112" data-pinit="registered" /></a></p>

<p>这是博主的WWDC2012笔记系列中的一篇，完整的笔记列表可以参看<a href="http://www.onevcat.com/tag/wwdc/">这里</a>。如果您是首次来到本站，也许您会有兴趣通过<a href="http://www.onevcat.com/feed">RSS</a>，或者通过页面下方的邮件订阅的方式订阅本站。</p>

<p>2007年的时候，Objective-C在TIOBE编程语言排名里还排在可怜的第45位，而随着移动互联网的迅速发展和iPhone，iPad等iOS设备的广阔市场前景，Objective-C也迅速崛起，走进了开发者的视野。在最近的TIOBE排名中，Objective-C达到了惊人的第4名，可以说已经成为当今世界上一门非常重要的编程语言。</p>

<p>而Objective-C现在主要是由Apple在负责维护了。一直以来Apple为了适应开发的发展需要，不断在完善OC以及相应的cocoa库，2.0中引入的property，随着iOS4引入的block，以及去年引入的ARC，都受到了绝大部分开发者的欢迎。几乎每年都有重大特性的加入，这不是每种语言都能做到的，更况且这些特性都为大家带来了众多的便利。</p>

<p><!--:-->
		
		<a href="/2012/06/modern-objective-c/" class="more-link">继续阅读</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-06-20T00:00:00+09:00" data-updated="true" itemprop="datePublished">Jun 20<span>th</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/category/neng-gong-qiao-jiang-ji/'>能工巧匠集</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/2012/06/what-is-new-in-cocoa-touch/" itemprop="url">WWDC 2012 Session笔记——200 What Is New in Cocoa Touch</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><!--:zh--><a href="http://www.onevcat.com/wp-content/uploads/2012/06/QQ20120620-1.png"><img class="aligncenter size-full wp-image-892" title="what-is-new-in-cocoa-touch" src="http://www.onevcat.com/wp-content/uploads/2012/06/QQ20120620-1.png" alt="" width="748" height="141" data-pinit="registered" /></a></p>

<p>这是博主的WWDC2012笔记系列中的一篇，完整的笔记列表可以参看<a href="http://www.onevcat.com/tag/wwdc/">这里</a>。如果您是首次来到本站，也许您会有兴趣通过<a href="http://www.onevcat.com/feed">RSS</a>，或者通过页面下方的邮件订阅的方式订阅本站。</p>

<p>之前写过<a href="http://www.onevcat.com/2012/06/%e5%bc%80%e5%8f%91%e8%80%85%e6%89%80%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84ios6-sdk%e6%96%b0%e7%89%b9%e6%80%a7/">一篇iOS6 SDK新内容的总览</a>，从这篇开始，将对WWDC 2012的我个人比较感兴趣的Session进行一些笔记，和之后的笔记一起应该可以形成一个比较完整的WWDC 2012 Session部分的个人记录。</p>

<p>因为WWDC的内容可谓众多，我自觉不太可能看完所有Session(其实也没有这个必要..)，所以对于内容覆盖上可能有所欠缺。另外我本身也只是一个iOS开发初学者加业余爱好者，因此很多地方也都不明白，不理解，因此难免有各种不足。这些笔记的最大作用是给自己做一些留底，同时帮助理解Session的内容。欢迎高手善意地指出我的错误和不足..谢谢！</p>

<p>所有的WWDC 2012 Session的视频和讲义可以在<a href="https://developer.apple.com/videos/wwdc/2012/">这里</a>找到，如果想看或者下载的话可能需要一个野生开发者账号(就是不用交99美金那种)。iOS6 Beta和Xcode4.5预览版现在已经提供开发者下载(需要家养开发者的账号，就在iOS Resource栏里)，当然网上随便搜索一下不是开发者肯定也能下载到，不过如果你不太懂的话还是不建议尝试iOS6 Beta，有时间限制麻烦不说，而且可能存在各种bug，Xcode4.5预览版同理..</p>

<p><!--:-->
		
		<a href="/2012/06/what-is-new-in-cocoa-touch/" class="more-link">继续阅读</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-06-12T00:00:00+09:00" data-updated="true" itemprop="datePublished">Jun 12<span>th</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/category/neng-gong-qiao-jiang-ji/'>能工巧匠集</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/2012/06/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84ios6-sdk%E6%96%B0%E7%89%B9%E6%80%A7/" itemprop="url">开发者所需要知道的iOS6 SDK新特性</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><!--:zh--><a href="http://www.onevcat.com/wp-content/uploads/2012/06/ios6.png"><img class="aligncenter size-full wp-image-859" title="ios6" src="http://www.onevcat.com/wp-content/uploads/2012/06/ios6.png" alt="" width="766" height="238" data-pinit="registered" /></a></p>

<p>欢迎转载本文，但是转载请注明本文出处： <strong><a href="http://2.gy/erSp" target="_blank">http://2.gy/erSp</a></strong></p>

<p>iOS6 beta和相应的SDK已经放出了，WWDC2012要进入session环节了。iOS6无疑是这届WWDC的重点，在keynote上面对消费者展示了很多新鲜的特性，而之后的seesion对于开发者来说应该是更为重要。这里先大概把iOS6里新增的开发者可能用到的特性做个简单的整理。之后我也会挑一些自己感兴趣的session做一些整理和翻译工作，也算是对自己的一种锻炼吧～相关的笔记整理如下：</p>

<p><a href="http://www.onevcat.com/2012/06/what-is-new-in-cocoa-touch/">Session 200 What&#8217;s New in Cocoa Touch</a>  Cocoa Touch新特性一览</p>

<p><a title="WWDC 2012 Session笔记——405 Modern Objective-C" href="http://www.onevcat.com/2012/06/modern-objective-c/">Session 405 Modern Objective-C</a> 先进Objective-C</p>

<p><a title="WWDC 2012 Session笔记——205 Introducing Collection Views" href="http://www.onevcat.com/2012/06/introducing-collection-views/">Session 205 Introducing Collection Views</a> Collection View入门</p>

<p><a title="WWDC 2012 Session笔记——219 Advanced Collection Views and Building Custom Layouts" href="http://www.onevcat.com/2012/08/advanced-collection-view/">Session 219 Advanced Collection Views and Building Custom Layouts</a> 高级Collection View和自定义布局</p>

<p><a title="WWDC 2012 Session笔记——202, 228, 232 AutoLayout（自动布局）入门" href="http://www.onevcat.com/2012/09/autoayout/">Session 202,228,232 AutoLayout使用</a></p>

<p><hr /></p>

<p><h3>地图</h3>
iOS6抛弃了一直用的google map，而使用了自家的地图服务。相应地，MapKit框架也自然变成和Apple自家的地图服务绑定了。随之而来的好处是因为都是自家的内容，所以整合和开放会更进一步，第三方app现在有机会和地图应用进行交互了。也就是说，不使用自身搭载地图信息的app现在可以打开地图应用，并且显示一些感兴趣的路线和地点，这对于路线规划和记录类的应用来说这是个好消息～<!--:--><!--:en--><a href="http://www.onevcat.com/wp-content/uploads/2012/06/ios6.png"><img class="aligncenter size-full wp-image-859" title="ios6" src="http://www.onevcat.com/wp-content/uploads/2012/06/ios6.png" alt="" width="766" height="238" data-pinit="registered" /></a></p>

<p>欢迎转载本文，但是转载请注明本文出处： <strong><a href="http://2.gy/erSp" target="_blank">http://2.gy/erSp</a></strong></p>

<p>iOS6 beta和相应的SDK已经放出了，WWDC2012要进入session环节了。iOS6无疑是这届WWDC的重点，在keynote上面对消费者展示了很多新鲜的特性，而之后的seesion对于开发者来说应该是更为重要。这里先大概把iOS6里新增的开发者可能用到的特性做个简单的整理。之后我也会挑一些自己感兴趣的session做一些整理和翻译工作，也算是对自己的一种锻炼吧～相关的笔记整理如下：</p>

<p><a href="http://www.onevcat.com/2012/06/what-is-new-in-cocoa-touch/">Session 200 What&#8217;s New in Cocoa Touch</a>  Cocoa Touch新特性一览</p>

<p><a title="WWDC 2012 Session笔记——405 Modern Objective-C" href="http://www.onevcat.com/2012/06/modern-objective-c/">Session 405 Modern Objective-C</a> 先进Objective-C</p>

<p><a title="WWDC 2012 Session笔记——205 Introducing Collection Views" href="http://www.onevcat.com/2012/06/introducing-collection-views/">Session 205 Introducing Collection Views</a> Collection View入门</p>

<p><a title="WWDC 2012 Session笔记——219 Advanced Collection Views and Building Custom Layouts" href="http://www.onevcat.com/2012/08/advanced-collection-view/">Session 219 Advanced Collection Views and Building Custom Layouts</a> 高级Collection View和自定义布局</p>

<p><a title="WWDC 2012 Session笔记——202, 228, 232 AutoLayout（自动布局）入门" href="http://www.onevcat.com/2012/09/autoayout/">Session 202,228,232 AutoLayout使用</a></p>

<p><hr /></p>

<p><h3>地图</h3>
iOS6抛弃了一直用的google map，而使用了自家的地图服务。相应地，MapKit框架也自然变成和Apple自家的地图服务绑定了。随之而来的好处是因为都是自家的内容，所以整合和开放会更进一步，第三方app现在有机会和地图应用进行交互了。也就是说，不使用自身搭载地图信息的app现在可以打开地图应用，并且显示一些感兴趣的路线和地点，这对于路线规划和记录类的应用来说这是个好消息～<!--:-->
		
		<a href="/2012/06/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%80%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84ios6-sdk%E6%96%B0%E7%89%B9%E6%80%A7/" class="more-link">继续阅读</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-06-11T00:00:00+09:00" data-updated="true" itemprop="datePublished">Jun 11<span>th</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/category/hu-yan-luan-yu-ji/'>胡言乱语集</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/2012/06/euro2012/" itemprop="url">EURO 2012</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><!--:zh--><a href="http://www.onevcat.com/wp-content/uploads/2012/06/euro2012.png"><img class="aligncenter size-full wp-image-853" title="euro2012" src="http://www.onevcat.com/wp-content/uploads/2012/06/euro2012.png" alt="" width="1024" height="256" data-pinit="registered" /></a></p>

<p>又是一届欧洲杯。</p>

<p>那一年，当各色时装铺满球场，当克林斯曼哭得像个小孩的时候，我4岁。那时的我，懵懂中认识了足球。</p>

<p>那一年，当小劳德鲁普挑起大梁，在绿茵上奔走书写丹麦童话的时候，我6岁。那时的我，刚懂得什么是足球。</p>

<p>那一年，当巴乔在玫瑰碗忧郁叹息，当塔法雷尔仰天长啸的时候，我8岁。那时的我，已经可以和小伙伴踢踢小场。</p>

<p>那一年，当高卢雄鸡昂首怒掏巴西，我和老爸做在电视前的地上一起喝酒看球的时候，我12岁。那时的我，已经是小学队里最出色的门将，奇拉维特和巴特兹是我的偶像。</p>

<p>那一年，当特雷泽盖打进金球绝杀意大利，我独自在电视前感叹人生如球场瞬息多变的时候，我14岁。那时的我，刚刚开始学会思考和冷静。</p>

<p>那一年，当小组赛第一场开始我就预言希腊夺冠，同学家人纷纷不信，而最终却拜服的时候，我18岁。那时的我，籍以生存的，是理性和惯性，更多的是一种纯粹和执着。</p>

<p>那一年，黄健翔高喊意大利万岁格罗索无敌。</p>

<p>那一年，和我几乎同龄的伊涅斯塔、席尔瓦，托雷斯和法布雷加斯的名字不过刚刚进入人们的视野，西班牙的黄金一代终于成型。</p>

<p>那一年，C罗梅西罗本集体哑火，身价越高状态越差的怪圈笼罩了所有的球星。</p>

<p>可以说，足球，陪伴我长大。关于足球的这些记忆，可能永远也无法抹去了。</p>

<p>而现在，在同样这块七千平米的草地上，又会演绎出什么样的故事呢…？</p>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-06-04T00:00:00+09:00" data-updated="true" itemprop="datePublished">Jun 4<span>th</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/category/neng-gong-qiao-jiang-ji/'>能工巧匠集</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/2012/06/arc-hand-by-hand/" itemprop="url">手把手教你ARC——iOS/Mac开发ARC入门和使用</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/QQ20120604-1.png" alt="Revolution of Objective-c" /></p>

<p>本文部分实例取自iOS 5 Toturail一书中关于ARC的教程和公开内容，仅用于技术交流和讨论。请不要将本文的部分或全部内容用于商用，谢谢合作。</p>

<p>欢迎转载本文，但是转载请注明本文出处：<a href="http://www.onevcat.com/2012/06/arc-hand-by-hand/">http://www.onevcat.com/2012/06/arc-hand-by-hand/</a></p>

<p>本文适合人群：对iOS开发有一定基础，熟悉iOS开发中内存管理的Reference Counting机制，对ARC机制有听闻很向往但是一直由于种种原因没有使用的童鞋。本文将从ARC机理入手对这个解放广大iOS开发者的伟大机制进行一个剖析，并逐步引导你开始使用ARC。一旦习惯ARC，你一定会被它的简洁高效所征服。</p>

<h2>写在开头</h2>

<p>虽然距离WWDC2011和iOS 5已经快一年时间，但是很多开发者并没有利用新方法来提高自己的水平，这点在ARC的使用上非常明显(特别是国内，基本很少见到同行转向ARC)。我曾经询问过一些同行为什么不转向使用ARC，很多人的回答是担心内存管理不受自己控制..其实我个人认为这是对于ARC机制了解不足从而不自信，所导致的对新事物的恐惧。而作为最需要“追赶时髦”的职业，这样的心态将相当不利。谨以此文希望能清楚表述ARC的机理和用法，也希望能够成为现在中文入门教学缺失的补充。</p>

<hr />

<h2>什么是ARC</h2>

<p>Automatic Reference Counting，自动引用计数，即ARC，可以说是WWDC2011和iOS5所引入的最大的变革和最激动人心的变化。ARC是新的LLVM 3.0编译器的一项特性，使用ARC，可以说一举解决了广大iOS开发者所憎恨的手动内存管理的麻烦。</p>

<p>在工程中使用ARC非常简单：只需要像往常那样编写代码，只不过永远不写<code>retain</code>,<code>release</code>和<code>autorelease</code>三个关键字就好～这是ARC的基本原则。当ARC开启时，编译器将自动在代码合适的地方插入<code>retain</code>, <code>release</code>和<code>autorelease</code>，而作为开发者，完全不需要担心编译器会做错（除非开发者自己错用ARC了）。好了，ARC相当简单吧～到此为止，本教程结束。</p>

<p>等等…也许还有其他问题，最严重的问题是“我怎么确定让ARC来管理不会出问题？”或者“用ARC会让程序性能下降吧”。对于ARC不能正处理内存管理的质疑自从ARC出生以来就一直存在，而现在越来越多的代码转向ARC并取得了很好的效果，这证明了ARC是一套有效的简化开发复杂程度的机制，另外通过研究ARC的原理，可以知道使用ARC甚至能提高程序的效率。在接下来将详细解释ARC的运行机理并且提供了一个step-by-step的教程，将非ARC的程序转换为ARC。</p>

<hr />

<h2>ARC工作原理</h2>

<p>手动内存管理的机理大家应该已经非常清楚了，简单来说，只要遵循以下三点就可以在手动内存管理中避免绝大部分的麻烦：</p>

<blockquote><p>如果需要持有一个对象，那么对其发送retain 如果之后不再使用该对象，那么需要对其发送release（或者autorealse） 每一次对retain,alloc或者new的调用，需要对应一次release或autorealse调用</p></blockquote>

<p>初学者可能仅仅只是知道这些规则，但是在实际使用时难免犯错。但是当开发者经常使用手动引用计数 Manual Referecen Counting(MRC)的话，这些规则将逐渐变为本能。你会发现少一个<code>release</code>的代码怎么看怎么别扭，从而减少或者杜绝内存管理的错误。可以说MRC的规则非常简单，但是同时也非常容易出错。往往很小的错误就将引起crash或者OOM之类的严重问题。</p>

<p>在MRC的年代里，为了避免不小心忘写<code>release</code>，Xcode提供了一个很实用的小工具来帮助可能存在的代码问题(Xcode3里默认快捷键Shift+A？不记得了)，可以指出潜在的内存泄露或者过多释放。而ARC在此基础上更进一步：ARC是Objective-C编译器的特性，而不是运行时特性或者垃圾回收机制，ARC所做的只不过是在代码编译时为你自动在合适的位置插入<code>release</code>或<code>autorelease</code>，就如同之前MRC时你所做的那样。因此，至少在效率上ARC机制是不会比MRC弱的，而因为可以在最合适的地方完成引用计数的维护，以及部分优化，使用ARC甚至能比MRC取得更高的运行效率。</p>

<h3>ARC机制</h3>

<p>学习ARC很简单，在MRC时代你需要自己<code>retain</code>一个想要保持的对象，而现在不需要了。现在唯一要做的是用一个指针指向这个对象，只要指针没有被置空，对象就会一直保持在堆上。当将指针指向新值时，原来的对象会被<code>release</code>一次。这对实例变量，synthesize的变量或者局部变量都是适用的。比如</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">firstName</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">textField</span><span class="p">.</span><span class="n">text</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>firstName</code>现在指向NSString对象，这时这个对象（<code>textField</code>的内容字符串）将被hold住。比如用字符串@“OneV&#8221;作为例子（虽然实际上不应该用字符串举例子，因为字符串的retainCount规则其实和普通的对象不一样，大家就把它当作一个普通的对象来看吧…），这个时候<code>firstName</code>持有了@&#8221;OneV&#8221;。</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic1.png" alt="一个strong指针" /></p>

<p>当然，一个对象可以拥有不止一个的持有者（这个类似MRC中的retainCount>1的情况）。在这个例子中显然<code>self.textField.text</code>也是@“OneV&#8221;，那么现在有两个指针指向对象@&#8221;OneV”(被持有两次，retainCount=2，其实对NSString对象说retainCount是有问题的，不过anyway～就这个意思而已.)。</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic2.png" alt="两个strong指向同一个对象" /></p>

<p>过了一会儿，也许用户在<code>textField</code>里输入了其他的东西，那么<code>self.textField.text</code>指针显然现在指向了别的字符串，比如@“onevcat&#8221;，但是这时候原来的对象已然是存在的，因为还有一个指针<code>firstName</code>持有它。现在指针的指向关系是这样的：</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic3.png" alt="其中一个strong指向了另一个对象" /></p>

<p>只有当<code>firstName</code>也被设定了新的值，或者是超出了作用范围的空间(比如它是局部变量但是这个方法执行完了或者它是实例变量但是这个实例被销毁了)，那么此时<code>firstName</code>也不再持有@“OneV&#8221;，此时不再有指针指向@&#8221;OneV&#8221;，在ARC下这种状况发生后对象@&#8221;OneV&#8221;即被销毁，内存释放。</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic4.png" alt="没有strong指向@&quot;OneV&quot;，内存释放" /></p>

<p>类似于<code>firstName</code>和<code>self.textField.text</code>这样的指针使用关键字<code>strong</code>进行标志，它意味着只要该指针指向某个对象，那么这个对象就不会被销毁。反过来说，ARC的一个基本规则即是，<strong>只要某个对象被任一<code>strong</code>指针指向，那么它将不会被销毁。如果对象没有被任何strong指针指向，那么就将被销毁</strong>。在默认情况下，所有的实例变量和局部变量都是<code>strong</code>类型的。可以说<code>strong</code>类型的指针在行为上和MRC时代<code>retain</code>的property是比较相似的。</p>

<p>既然有<code>strong</code>，那肯定有<code>weak</code>咯～<code>weak</code>类型的指针也可以指向对象，但是并不会持有该对象。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">__weak</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">weakName</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">textField</span><span class="p">.</span><span class="n">text</span>
</span></code></pre></td></tr></table></div></figure>


<p>得到的指向关系是：</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic5.png" alt="一个strong和一个weak指向同一个对象" /></p>

<p>这里声明了一个<code>weak</code>的指针<code>weakName</code>，它并不持有@“onevcat&#8221;。如果<code>self.textField.text</code>的内容发生改变的话，根据之前提到的<strong>&#8220;只要某个对象被任一strong指针指向，那么它将不会被销毁。如果对象没有被任何strong指针指向，那么就将被销毁”</strong>原则，此时指向@“onevcat&#8221;的指针中没有<code>strong</code>类型的指针，@&#8221;onevcat&#8221;将被销毁。同时，在ARC机制作用下，所有指向这个对象的<code>weak</code>指针将被置为<code>nil</code>。这个特性相当有用，相信无数的开发者都曾经被指针指向已释放对象所造成的EXC_BAD_ACCESS困扰过，使用ARC以后，不论是<code>strong</code>还是<code>weak</code>类型的指针，都不再会指向一个dealloced的对象，从<strong>根源上解决了意外释放导致的crash</strong>。</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic6.png" alt="strong指向另外对象，内存释放，weak自动置nil" /></p>

<p>不过在大部分情况下，<code>weak</code>类型的指针可能并不会很常用。比较常见的用法是在两个对象间存在包含关系时：对象1有一个<code>strong</code>指针指向对象2，并持有它，而对象2中只有一个<code>weak</code>指针指回对象1，从而避免了循环持有。一个常见的例子就是oc中常见的delegate设计模式，viewController中有一个<code>strong</code>指针指向它所负责管理的UITableView，而UITableView中的<code>dataSource</code>和<code>delegate</code>指针都是指向viewController的<code>weak</code>指针。可以说，<code>weak</code>指针的行为和MRC时代的<code>assign</code>有一些相似点，但是考虑到<code>weak</code>指针更聪明些（会自动指向nil），因此还是有所不同的。细节的东西我们稍后再说。</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic7.png" alt="一个典型的delegate设计模式" /></p>

<p>注意类似下面的代码似乎是没有什么意义的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">__weak</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat:</span><span class="err">…</span><span class="p">];</span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span><span class="n">str</span><span class="p">);</span> <span class="c1">//输出是&quot;(null)&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于<code>str</code>是<code>weak</code>，它不会持有alloc出来的<code>NSString</code>对象，因此这个对象由于没有有效的<code>strong</code>指针指向，所以在生成的同时就被销毁了。如果我们在Xcode中写了上面的代码，我们应该会得到一个警告，因为无论何时这种情况似乎都是不太可能出现的。你可以把<strong>weak换成</strong>strong来消除警告，或者直接前面什么都不写，因为ARC中默认的指针类型就是<code>strong</code>。</p>

<p>property也可以用<code>strong</code>或<code>weak</code>来标记，简单地把原来写<code>retain</code>和<code>assign</code>的地方替换成<code>strong</code>或者<code>weak</code>就可以了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">firstName</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">weak</span><span class="p">)</span> <span class="kt">id</span>  <span class="n">delegate</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>ARC可以为开发者节省很多代码，使用ARC以后再也不需要关心什么时候<code>retain</code>，什么时候<code>release</code>，但是这并不意味你可以不思考内存管理，你可能需要经常性地问自己这个问题：谁持有这个对象？</p>

<p>比如下面的代码，假设<code>array</code>是一个<code>NSMutableArray</code>并且里面至少有一个对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">objectAtIndex:</span><span class="mi">0</span><span class="p">];</span><span class="err"> </span>
</span><span class='line'><span class="p">[</span><span class="n">array</span> <span class="nl">removeObjectAtIndex:</span><span class="mi">0</span><span class="p">];</span><span class="err"> </span>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span><span class="n">obj</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在MRC时代这几行代码应该就挂掉了，因为<code>array</code>中0号对象被remove以后就被立即销毁了，因此obj指向了一个dealloced的对象，因此在NSLog的时候将出现EXC_BAD_ACCESS。而在ARC中由于obj是<code>strong</code>的，因此它持有了<code>array</code>中的首个对象，<code>array</code>不再是该对象的唯一持有者。即使我们从<code>array</code>中将obj移除了，它也依然被别的指针持有，因此不会被销毁。</p>

<h3>一点提醒</h3>

<p>ARC也有一些缺点，对于初学者来说，可能仅只能将ARC用在objective-c对象上(也即继承自NSObject的对象)，但是如果涉及到较为底层的东西，比如Core Foundation中的malloc()或者free()等，ARC就鞭长莫及了，这时候还是需要自己手动进行内存管理。在之后我们会看到一些这方面的例子。另外为了确保ARC能正确的工作，有些语法规则也会因为ARC而变得稍微严格一些。</p>

<p>ARC确实可以在适当的地方为代码添加<code>retain</code>或者<code>release</code>，但是这并不意味着你可以完全忘记内存管理，因为你必须在合适的地方把<code>strong</code>指针手动设置到nil，否则app很可能会oom。简单说还是那句话，你必须时刻清醒谁持有了哪些对象，而这些持有者在什么时候应该变为指向<code>nil</code>。</p>

<p>ARC必然是Objective-C以及Apple开发的趋势，今后也会有越来越多的项目采用ARC(甚至不排除MRC在未来某个版本被弃用的可能)，Apple也一直鼓励开发者开始使用ARC，因为它确实可以简化代码并增强其稳定性。可以这么说，使用ARC之后，由于内存问题造成的crash基本就是过去式了(OOM除外 :P)</p>

<p>我们正处于由MRC向ARC转变的节点上，因此可能有时候我们需要在ARC和MRC的代码间来回切换和适配。Apple也想到了这一点，因此为开发这提供了一些ARC和非ARC代码混编的机制，这些也将在之后的例子中列出。另外ARC甚至可以用在C++的代码中，而通过遵守一些代码规则，iOS 4里也可以使用ARC(虽然我个人认为在现在iOS 6都呼之欲出的年代已经基本没有需要为iOS 4做适配的必要了)、</p>

<p>总之，聪明的开发者总会尝试尽可能的自动化流程，已减轻自己的工作负担，而ARC恰恰就为我们提供了这样的好处：自动帮我们完成了很多以前需要手动完成的工作，因此对我来说，转向ARC是一件不需要考虑的事情。</p>

<hr />

<h2>具体操作</h2>

<p>说了这么多，终于可以实践一下了。在决定使用ARC后，很多开发者面临的首要问题是不知如何下手。因为可能手上的项目已经用MRC写了一部分，不想麻烦做转变；或者因为新项目里用ARC时遇到了奇怪的问题，从而放弃ARC退回MRC。这都是常见的问题，而在下面，将通过一个demo引导大家彻底转向ARC的世界。</p>

<h3>Demo</h3>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic8.png" alt="Demo" /></p>

<p>例子很简单，这是一个查找歌手的应用，包含一个简单的UITableView和一个搜索框，当用户在搜索框搜索时，调用<a href="http://musicbrainz.org/">MusicBrainz</a>的API完成名字搜索和匹配。MusicBrainz是一个开放的音乐信息平台，它提供了一个免费的XML网页服务，如果对MusicBrainz比较有兴趣的话，可以到它的官网逛一逛。</p>

<p>Demo的起始例子可以从<a href="http://www.onevcat.com/wp-content/uploads/2012/06/ArtistsStarter.zip">这里下载</a>，为了照顾新人，在这边进行简单说明。在Xcode中打开下载的例子，应该可以看到如下内容(Xcode和iOS开发熟练者请跳过此段)</p>

<blockquote><p>AppDelegate.h/m 这是整个app的delegate，没什么特殊的，每个iOS/Mac程序在main函数以后的入口，由此进入app的生命周期。在这里加载了最初的viewController并将其放到Window中展示出来。另外appDelegate还负责处理程序开始退出等系统委托的事件</p>

<p>MainViewController.h/m/xib 这个demo最主要的ViewController，含有一个TableView和一个搜索条。 SoundEffect.h/m 简单的播放声音的类，在MusicBrainz搜索完毕时播放一个音效。 main.m 程序入口，所有c程序都从main函数开始执行</p>

<p>AFHTTPRequestOperation.h/m 这是有名的网络框架AFNetworking的一部分，用来帮助等简单地处理web服务请求。这里只包含了这一个类而没有将全部的AFNetworking包括进来，因为我们只用了这一个类。完整的框架代码可以在github的相关页面上找到<a href="https://github.com/gowalla/AFNetworking">https://github.com/gowalla/AFNetworking</a></p>

<p>SVProgresHUD.h/m/bundle 是一个常用的进度条指示，当搜索的时候出现以提示用户正在搜索请稍后。bundle是资源包，里面包含了几张该类用到的图片，打进bundle包的目的一方面是为了资源容易管理，另一方面也是主要方面时为了不和其他资源发生冲突(Xcode中资源名字是资源的唯一标识，同名字的资源只能出现一次，而放到bundle包里可以避免这个潜在的问题)。SVProgresHUD可以在这里找到<a href="https://github.com/samvermette/SVProgressHUD">https://github.com/samvermette/SVProgressHUD</a></p></blockquote>

<p>快速过一遍这个应用吧：<code>MainViewController</code>是<code>UIViewController</code>的子类，对应的xib文件定义了对应的<code>UITableView</code>和<code>UISearchBar</code>。<code>TableView中</code>显示<code>searchResult</code>数组中的内容。当用户搜索时，用AFHTTPRequestOperation发一个HTTP请求，当从MusicBrainz得到回应后将结果放入<code>searchResult</code>数组中并用<code>tableView</code>显示，当返回结果是空时在<code>tableView</code>中显示没找到。主要的逻辑都在MainViewController.m中的<code>-searchBarSearchButtonClicked:</code>方法中，生成了用于查询的URL，根据MusicBrainz的需求替换了请求的header，并且完成了返回逻辑，然后在主线程中刷新UI。整个程序还是比较简单的～</p>

<h3>MRC到ARC的自动转换</h3>

<p>回到正题，我们讨论的是ARC，关于REST API和XML解析的技术细节就暂时先忽略吧..整个程序都是用MRC来进行内存管理的，首先来让我们把这个demo转成ARC吧。基本上转换为ARC意味着把所有的<code>retain</code>,<code>release</code>和<code>autorelease</code>关键字去掉，在之前我们明确几件事情:</p>

<ul>
<li>Xcode提供了一个ARC自动转换工具，可以帮助你将源码转为ARC</li>
<li>当然你也可以自己动手完成ARC转换</li>
<li>同时你也可以指定对于某些你不想转换的代码禁用ARC，这对于很多庞大复杂的还没有转至ARC的第三方库帮助很大，因为不是你写的代码你想动手修改的话代码超级容易mess…</li>
</ul>


<p>对于我们的demo，为了说明问题，这三种策略我们都将采用，注意这仅仅只是为了展示如何转换。实际操作中不需要这么麻烦，而且今后的绝大部分情况应该是从工程建立开始就是ARC的。</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic9.png" alt="选择LLVM compiler 3.0" /></p>

<p>首先，ARC是LLVM3.0编译器的特性，而老的工程特别是Xcode3时代的工程的默认编译器很可能是GCC或者LLVM-GCC，因此第一步就是确认编译器是否正确。<strong>在Project设置面板，选择target，在Build Settings中将Compiler for C/C++/Objective-C选为Apple LLVM compiler 3.0或以上。</strong>为了确保之后转换的顺利，在这里我个人建议最好把Treat Warnings as Errors和 Run Static Analyzer都打开，确保在改变编译器后代码依旧没有警告或者内存问题(虽然静态分析可能不太能保证这一点，但是聊胜于无)。好了～clean(<code>Shift+Cmd+K</code>)以后Bulid一下试试看，经过修改后的demo工程没有任何警告和错误，这是很好的开始。（对于存在警告的代码，这里是很好的修复的时机..请在转换前确保原来的代码没有内存问题）。</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic10.png" alt="打开ARC" /></p>

<p>接下来就是完成从MRC到ARC的伟大转换了。还是在Build Settings页面，把Objective-C Automatic Reference Counting改成YES(如果找不到的话请看一看搜索栏前面的小标签是不是调成All了..这个选项在Basic里是不出现的)，这样我们的工程就将在所有源代码中启用ARC了。然后…试着编译一下看看，嗯..无数的错误。</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic11.png" alt="请耐心聆听编译器的倾诉，因为很多时候它是你唯一的伙伴" /></p>

<p>这是很正常的，因为ARC里不允许出现retain,release之类的，而MRC的代码这些是肯定会有的东西。我们可以手动一个一个对应地去修复这些错误，但是这很麻烦。Xcode为我们提供了一个自动转换工具，可以帮助重写源代码，简单来说就是去掉多余的语句并且重写一些property关键字。</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic12.png" alt="使用Xcode自带的转换ARC工具" /></p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic13.png" alt="选择要转换的文件" /></p>

<p>这个小工具是Edit->Refactor下的Convert to Objective-C ARC，点击后会让我们选择要转换哪几个文件，在这里为了说明除了自动转换外的方法，我们不全部转换，而只是选取其中几个转换(<code>MainViewController.m</code>和<code>AFHTTPRequestOperation.m</code>不做转换，之后我们再手动将这两个转为ARC)。注意到这个对话框上有个警告标志告诉我们target已经是ARC了，这是由于之前我们在Build Settings里已经设置了启用ARC，其实直接在这里做转换后Xcode会自动帮我们开启ARC。点击检查后，Xcode告诉我们一个不幸的消息，不能转换，需要修复ARC readiness issues..后面还告诉我们要看到所有的所谓的ARC readiness issues，可以到设置的General里把Continue building after errors勾上…What the f**k…好吧～先乖乖听从Xcode的建议&#8221;Cmd+,“然后Continue building after errors打勾然后再build。</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic14.png" alt="乖乖听话，去把勾打上" /></p>

<p>问题依旧，不过在issue面板里应该可以看到所有出问题的代码了。在我们的例子里，问题出在SoundEffect.m里：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSURL</span> <span class="o">*</span><span class="n">fileURL</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBundle</span> <span class="n">mainBundle</span><span class="p">]</span> <span class="nl">URLForResource:</span><span class="n">filename</span> <span class="nl">withExtension:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">fileURL</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">SystemSoundID</span> <span class="n">theSoundID</span><span class="p">;</span>
</span><span class='line'>  <span class="n">OSStatus</span> <span class="n">error</span> <span class="o">=</span> <span class="n">AudioServicesCreateSystemSoundID</span><span class="p">((</span><span class="n">CFURLRef</span><span class="p">)</span><span class="n">fileURL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">theSoundID</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">kAudioServicesNoError</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">soundID</span> <span class="o">=</span> <span class="n">theSoundID</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里代码尝试把一个<code>NSURL</code>指针强制转换为一个<code>CFURLRef</code>指针。这里涉及到一些Core Services特别是Core Foundation(CF)的东西，AudioServicesCreateSystemSoundID()函数接受CFURLRef为参数，这是一个CF的概念，但是我们在较高的抽象层级上所建立的是<code>NSURL</code>对象。在Cocoa框架中，有很多顶层对象对底层的抽象，而在使用中我们往往可以不加区别地对这两种对象进行同样的对待，这类对象即为可以&#8221;自由桥接&#8221;的对象(toll-free bridged)。NSURL和CFURLRef就是一对好基友好例子，在这里其实<code>CFURLRef</code>和<code>NSURL</code>是可以进行替换的。</p>

<p>通常来说为了代码在底层级上的正确，在iOS开发中对基于C的API的调用所传入的参数一般都是CF对象，而Objective-C的API调用都是传入NSObject对象。因此在采用自由桥接来调用C API的时候就需要进行转换。但是在使用ARC编译的时候，因为内存管理的原因，编译器需要知道对这些桥接对象要实行什么样的操作。如果一个NSURL对象替代了CFURLRef，那么在作用区域外，应该由谁来决定内存释放和对象销毁呢？为了解决这个问题，引入了<strong>bridge,</strong>bridge_transfer和__bridge_retained三个关键字。关于选取哪个关键字做转换，需要由实际的代码行为来决定。如果对于自由桥接机制感兴趣，大家可以自己找找的相关内容，比如<a href="http://developer.apple.com/library/mac/#documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/20002401-767858">适用类型</a>、<a href="http://www.mikeash.com/pyblog/friday-qa-2010-01-22-toll-free-bridging-internals.html">内部机制</a>和<a href="http://ridiculousfish.com/blog/posts/bridge.html">一个简介</a>～之后我也会对这个问题做进一步说明</p>

<p>回到demo，我们现在在上面的代码中(CFURLRef)前加上<code>__bridge</code>进行转换。然后再运行ARC转换工具，这时候检查应该没有其他问题了，那么让我们进行转换吧～当然在真正转换之前会有一个预览界面，在这里我们最好检查一下转换是不是都按照预想进行了..要是出现大面积错误又没有备份或者出现各种意外的话就可以哭了…</p>

<p>前后变化的话比较简单，基本就是去掉不需要的代码和改变property的类型而已，其实有信心的话不太需要每次都看，但是如果是第一次执行ARC转换的操作的话，我还是建议稍微看一下变化，这样能对ARC有个直观上的了解。检查一遍，应该没什么问题了..需要注意的是main.m里关于autoreleasepool的变化以及所有dealloc调用里的[super dealloc]的删除，它们同样是MRC到ARC的主要变化..</p>

<p>好了～转换完成以后我们再build看看..应该会有一些警告。对于原来<code>retain</code>的property，比较保险的做法是转为<code>strong</code>，在LLVM3.0中自动转换是这样做的，但是在3.1中property默认并不是<code>strong</code>，这样在使用property赋值时存在警告，我们在property声明里加上<code>strong</code>就好了～然后就是SVProgressHUD.m里可能存在问题，这是由于原作者把<code>release</code>的代码和其他代码写在一行了.导致自动转换时只删掉了部分，而留下了部分不应该存在的代码，删掉对变量的空的调用就好了..</p>

<h3>自动转换之后的故事</h3>

<p>然后再编译，没有任何错误和警告了，好棒～等等…我们刚才没有对MainViewController和AFHTTPRequestOperation进行处理吧，那么这两个文件里应该还存在<code>release</code>之类的东西吧..？看一看这两个文件，果然有各种<code>release</code>，但是为什么能编译通过呢？！明明刚才在自动转换前他们还有N多错的嘛…答案很简单，在自动转换的时候因为我们没有勾选这两个文件，因此编译器在自动转换过后为这两个文件标记了&#8221;不使用ARC编译&#8221;。可以看到在target的Building Phases下，MainViewController.m和AFHTTPRequestOperation.m两个文件后面被加上了<code>-fno-objc-arc</code>的编译标记，被加上该标记的文件将不使用ARC规则进行编译。（相对地，如果你想强制对某几个文件启用ARC的话，可以为其加上<code>-fobjc-arc</code>标记）</p>

<p><img src="http://www.onevcat.com/wp-content/uploads/2012/06/arcpic15.png" alt="强制不是用ARC" /></p>

<p>提供这样的编译标记的原因是显而易见的，因为总是有一部分的第三方代码并没有转换为ARC(可能是由于维护者犯懒或者已经终止维护)，所以对于这部分代码，为了迅速完成转换，最好是使用-fno-objc-arc标记来禁止在这些源码上使用ARC。</p>

<p>为了方便查找，再此列出一些在转换时可能出现的问题，当然在我们使用ARC时也需要注意避免代码中出现这些问题：</p>

<ul>
<li>“Cast … requires a bridged cast”</li>
</ul>


<p>  <strong><em>这是我们在demo中遇到的问题，不再赘述</em></strong></p>

<ul>
<li>Receiver type ‘X’ for instance message is a forward declaration</li>
</ul>


<p>  <strong><em>这往往是引用的问题。ARC要求完整的前向引用，也就是说在MRC时代可能只需要在.h中申明@class就可以，但是在ARC中如果调用某个子类中未覆盖的父类中的方法的话，必须对父类.h引用，否则无法编译。</em></strong></p>

<ul>
<li>Switch case is in protected scope</li>
</ul>


<p>  <strong><em>现在switch语句必须加上{}了，ARC需要知道局部变量的作用域，加上{}后switch语法更加严格，否则遇到没有break的分支的话内存管理会出现问题。</em></strong></p>

<ul>
<li>A name is referenced outside the NSAutoreleasePool scope that it was declared in&#8230;</li>
</ul>


<p>  <strong><em>这是由于写了自己的autoreleasepool，而在转换时在原来的pool中申明的变量在新的@autoreleasepool中作用域将被局限。解决方法是把变量申明拿到pool的申请之前。</em></strong></p>

<ul>
<li>ARC forbids Objective-C objects in structs or unions</li>
</ul>


<p>  <strong><em>可以说ARC所引入的最严格的限制是不能在C结构体中放OC对象了..因此类似下面这样的代码是不可用的</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">UIImage</span> <span class="o">*</span><span class="n">selectedImage</span><span class="p">;</span>
</span><span class='line'>  <span class="n">UIImage</span> <span class="o">*</span><span class="n">disabledImage</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">ButtonImages</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个问题只有乖乖想办法了..改变原来的结构什么的..</p>

<h3>手动转换</h3>

<p>刚才做了对demo的大部分转换，还剩下了MainViewController和AFHTTPRequestOperation是MRC。但是由于使用了<code>-fno-objc-arc</code>，因此现在编译和运行都没有问题了。下面我们看看如何手动把MainViewController转为ARC，这也有助于进一步理解ARC的规则。</p>

<p>首先，我们需要转变一下观念…对于MainViewController.h，在.h中申明了两个实例变量：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">MainViewController</span> : <span class="nc">UIViewController</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
</span><span class='line'>  <span class="n">NSMutableString</span> <span class="o">*</span><span class="n">currentStringValue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们不妨仔细考虑一下，为什么在interface里出现了实例变量的申明？通常来说，实例变量只是在类的实例中被使用，而你所写的类的使用者并没有太多必要了解你的类中有哪些实例变量。而对于绝大部分的实例变量，应该都是<code>protected</code>或者<code>private</code>的，对它们的操作只应该用<code>setter</code>和<code>getter</code>，而这正是property所要做的工作。可以说，<strong>将实例变量写在头文件中是一种遗留的陋习</strong>。更好的写实例变量名字的地方应当与类实现关系更为密切，为了隐藏细节，我们应该考虑将它们写在@implementation里。好消息是，在LLVM3.0中，不论是否开启ARC，编译器是支持将实例变量写到实现文件中的。甚至如果没有特殊需要又用了property，我们都不应该写无意义的实例变量申明，因为在@synthesize中进行绑定时，我们就可以设置变量名字了，这样写的话可以让代码更加简洁。</p>

<p>在这里我们对着两个实例变量不需要property(外部成员不应当能访问到它们)，因此我们把申明移到.m里中。修改后的.h是这样的，十分简洁一看就懂～</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import </span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MainViewController</span> : <span class="nc">UIViewController</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">retain</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">UITableView</span> <span class="o">*</span><span class="n">tableView</span><span class="p">;</span><span class="err">  </span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">retain</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">UISearchBar</span> <span class="o">*</span><span class="n">searchBar</span><span class="p">;</span><span class="err"> </span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后.m的开头变成这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">MainViewController</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span><span class="err"> </span>
</span><span class='line'>  <span class="n">NSMutableString</span> <span class="o">*</span><span class="n">currentStringValue</span><span class="p">;</span><span class="err"> </span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样的写法让代码相当灵活，而且不得不承认.m确实是这些实例变量的应该在的地方…build一下，没问题..当然对于SoundEffect类也可以做相似的操作，这会让使用你的类的人很开心，因为.h越简单越好..P.S.另外一个好处可以减少.h里的引用，减少编译时间(虽然不明显=。=)</p>

<p>然后就可以在MainViewController里启用ARC了，方法很简单，删掉Build Phases里相关文件的-fno-objc-arc标记就可以了～然后..然后当然是一大堆错误啦。我们来手动一个个改吧，虽然谈不上乐趣，但是成功以后也会很有成就～(如果你不幸在启用ARC后build还是成功了，恭喜你遇到了Xcode的bug，请Cmd+Q然后重新打开Xcode把=_=)</p>

<h4>dealloc</h4>

<p>红色最密集的地方是<code>dealloc</code>，因为每一行都是<code>release</code>。由于在这里<code>dealloc</code>并没有做除了<code>release</code>和<code>super dealloc</code>之外的任何事情，因此简单地把整个方法删掉就好了。当然，在对象被销毁时，<code>dealloc</code>还是会被调用的，因此我们在需要对非ARC管理的内存进行管理和必要的逻辑操作的时候，还是应该保留<code>dealloc</code>的，当然这涉及到CF以及以下层的东西：比如对于<code>retain</code>的CF对象要<code>CFRelease()</code>，对于<code>malloc()</code>到堆上的东西要<code>free()</code>掉，对于添加的<code>observer</code>可以在这里remove，schedule的timer在这里<code>invalidate</code>等等～<code>[super dealloc]</code>这个消息也不再需要发了，ARC会自动帮你搞定。</p>

<p>另外，在MRC时代一个常做的事情是在<code>dealloc</code>里把指向自己的delegate设成nil(否则就等着EXC_BAD_ACCESS吧 :P)，而现在一般delegate都是<code>weak</code>的，因此在self被销毁后这个指针自动被置成<code>nil</code>了，你不用再为之担心，好棒啊..</p>

<h4>去掉各种release和autorelease</h4>

<p>这个很直接，没有任何问题。去掉就行了～不再多说</p>

<h4>讨论一下Property</h4>

<p>在MainViewController.m里的类扩展中定义了两个property：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">MainViewController</span> <span class="p">()</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">retain</span><span class="p">)</span> <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">searchResults</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">retain</span><span class="p">)</span> <span class="n">SoundEffect</span> <span class="o">*</span><span class="n">soundEffect</span><span class="p">;</span><span class="err"> </span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>申明的类型是<code>retain</code>，关于<code>retain</code>,<code>assign</code>和<code>copy</code>的讨论已经烂大街了，在此不再讨论。在MRC的年代使用property可以帮助我们使用dot notation的时候简化对象的<code>retain</code>和<code>copy</code>，而在ARC时代，这就显得比较多余了。<del>在我看来，使用property和点方法来调用setter和getter是不必要的。property只在将需要的数据在.h中暴露给其他类时才需要，而在本类中，只需要用实例变量就可以。</del>(更新，现在笔者在这点上已经不纠结了，随意就好，自己明白就行。但是也许还是用点方法会好一些，至少可以分清楚到底是操作了实例变量还是调用了setter和getter)。因此我们可以移去searchResults和soundEffect的@property和@synthesize，并将起移到实例变量申明中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &quot;plementation MainViewController</span>
</span><span class='line'><span class="p">{</span><span class="err"> </span>
</span><span class='line'>  <span class="n">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span><span class="err"> </span>
</span><span class='line'>  <span class="n">NSMutableString</span> <span class="o">*</span><span class="n">currentStringValue</span><span class="p">;</span>
</span><span class='line'>  <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">searchResults</span><span class="p">;</span>
</span><span class='line'>  <span class="n">SoundEffect</span> <span class="o">*</span><span class="n">soundEffect</span><span class="p">;</span><span class="err"> </span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>相应地，我们需要将对应的<code>self.searchResult</code>和<code>self.soundEffect</code>的self.都去去掉。在这里需要注意的是，虽然我们去掉了soundEffect的property和synthesize，但是我们依然有一个lazy loading的方法<code>-(SoundEffect *)soundEffect</code>，神奇之处在于(可能你以前也不知道)，点方法并不需要@property关键字的支持，虽然大部分时间是这么用的..(property只是对setter或者getter的申明，而点方法是对其的调用，在这个例子的实现中我们事实上实现了-soundEffect这个getter方法，所以点方法在等号右边的getter调用是没有问题的)。为了避免误解，建议把self.soundEffect的getter调用改写成[self soundEffect]。</p>

<p>然后我们看看.h里的property～里面有两个<code>retain</code>的IBOutlet。<code>retain</code>关键字在ARC中是依旧可用的，它在ARC中所扮演的角色和<code>strong</code>完全一样。为了避免迷惑，最好在需要的时候将其写为strong，那样更符合ARC的规则。对于这两个property，我们将其申明为<code>weak</code>(事实上，如果没有特别意外，除了最顶层的IBOutlet意外，自己写的outlet都应该是<code>weak</code>)。通过加载xib得到的用户界面，在其从xib文件加载时，就已经是view hierarchy的一部分了，而view hierarchy中的指向都是strong的。因此outlet所指向的UI对象不应当再被hold一次了。将这些outlet写为weak的最显而易见的好处是你就不用再viewDidUnload方法中再将这些outlet设为nil了(否则就算view被摧毁了，但是由于这些UI对象还在被outlet指针指向而无法释放，代码简洁了很多啊..)。</p>

<p>在我们的demo中将IBOutlet的property改为<code>weak</code>并且删掉viewDidUnload中关于这两个IBOutlet的内容～</p>

<p>总结一下新加入的property的关键字类型：</p>

<ul>
<li>strong 和原来的retain比较相似，strong的property将对应__strong的指针，它将持有所指向的对象</li>
<li>weak 不持有所指向的对象，而且当所指对象销毁时能将自己置为nil，基本所有的outlet都应该用weak</li>
<li>unsafe_unretained 这就是原来的assign。当需要支持iOS4时需要用到这个关键字</li>
<li>copy 和原来基本一样..copy一个对象并且为其创建一个strong指针</li>
<li>assign 对于对象来说应该永远不用assign了，实在需要的话应该用unsafe_unretained代替(基本找不到这种时候，大部分assign应该都被weak替代)。但是对于基本类型比如int,float,BOOL这样的东西，还是要用assign。</li>
</ul>


<p>特别地，对于<code>NSString</code>对象，在MRC时代很多人喜欢用copy，而ARC时代一般喜欢用strong…(我也不懂为什么..求指教)</p>

<h4>自由桥接的细节</h4>

<p>MainViewController现在剩下的问题都是桥接转换问题了～有关桥接的部分有三处：</p>

<ul>
<li>(NSString *)CFURLCreateStringByAddingPercentEscapes(…)：CFStringRef至NSString *</li>
<li>(CFStringRef)text：NSString *至CFStringRef</li>
<li>(CFStringRef)@“!<em>‘();:@&amp;=+$,/?%#[]&#8221;：NSString </em>至CFStringRef</li>
</ul>


<p>编译器对前两个进行了报错，最后一个是常量转换不涉及内存管理。</p>

<p>关于toll-free bridged，如果不进行细究，<code>NSString</code>和<code>CFStringRef</code>是一样的东西，新建一个<code>CFStringRef</code>可以这么做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFStringRef</span> <span class="n">s1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat:</span><span class="s">@&quot;Hello, %@!&quot;</span><span class="p">,</span><span class="n">name</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后，这里<code>alloc</code>了而s1是一个CF指针，要释放的话，需要这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFRelease</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>相似地可以用<code>CFStringRef</code>来转成一个<code>NSString</code>对象(MRC)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFStringRef</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">CFStringCreateWithCString</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span><span class="n">bytes</span><span class="p">,</span> <span class="n">kCFStringEncodingMacRoman</span><span class="p">);</span><span class="err"> </span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">s3</span> <span class="o">=</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">s2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// release the object when you&#39;re done   </span>
</span><span class='line'><span class="p">[</span><span class="n">s3</span> <span class="n">release</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>在ARC中，编译器需要知道这些指针应该由谁来负责释放，如果把一个<code>NSObject</code>看做是CF对象的话，那么ARC就不再负责它的释放工作(记住ARC是only for NSObject的)。对于不需要改变持有者的对象，直接用简单的<strong>bridge就可以了，比如之前在SoundEffect.m做的转换。在这里对于(CFStringRef)text这个转换，ARC已经负责了text这个NSObject的内存管理，因此这里我们需要一个简单的</strong>bridge。而对于<code>CFURLCreateStringByAddingPercentEscapes</code>方法，方法中的create暗示了这个方法将形成一个新的对象，如果我们不需要<code>NSString</code>转换，那么为了避免内存的问题，我们需要使用<code>CFRelease</code>来释放它。而这里我们需要一个<code>NSString</code>，因此我们需要告诉编译器接手它的内存管理工作。这里我们使用<strong>bridge_transfer关键字，将内存管理权由CF object移交给NSObject(或者说ARC)。如果这里我们只用</strong>bridge的话，内存管理的负责人没有改变，那么这里就会出现一个内存泄露。另外有时候会看到<code>CFBridgingRelease()</code>，这其实就是transfer cast的内联写法..是一样的东西。总之，需要记住的原则是，当在涉及CF层的东西时，如果函数名中有含有Create, Copy, 或者Retain之一，就表示返回的对象的retainCount+1了，对于这样的对象，最安全的做法是将其放在<code>CFBridgingRelease()</code>里，来平衡<code>retain</code>和<code>release</code>。</p>

<p>还有一种bridge方式，<code>__bridge_retained</code>。顾名思义，这种转换将在转换时将retainCount加1。和<code>CFBridgingRelease()</code>相似，也有一个内联方法<code>CFBridgingRetain()</code>来负责和<code>CFRelease()</code>进行平衡。</p>

<p>需要注意的是，并非所有的CF对象都是自由桥接的，比如Core Graphics中的所有对象都不是自由桥接的(如<code>CGImage</code>和<code>UIImage</code>，<code>CGColor</code>和<code>UIColor</code>)。另外也不是只有自由桥接对象才能用bridge来桥接，一个很好的特例是void <em>(指向任意对象的指针，类似id)，对于void </em>和任意对象的转换，一般使用<code>_bridge</code>。(这在将ARC运用在Cocos2D中很有用)</p>

<h4>终于搞定了</h4>

<p>至此整个工程都ARC了～对于AFHTTPRequestOperation这样的不支持ARC的第三方代码，我们的选择一般都是就不使用ARC了(或者等开源社区的大大们更新ARC适配版本)。可以预见，在近期会有越来越多的代码转向ARC，但是也一定会有大量的代码暂时或者永远保持MRC等个，所以对于这些代码就不用太纠结了～</p>

<hr />

<h2>写在最后</h2>

<p>写了那么多，希望你现在能对ARC有个比较全面的了解和认识了。ARC肯定是以后的趋势，也确实能让代码量大大降低，减少了很多无意义的重复工作，还提高了app的稳定性。但是凡事还是纸上得来终觉浅，希望作为开发者的你，在下一个工程中去尝试用用ARC～相信你会和我一样，马上爱上这种make life easier的方式的～</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-05-16T00:00:00+09:00" data-updated="true" itemprop="datePublished">May 16<span>th</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/category/bu-xing-chun-se-ji/'>不醒春色集</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/2012/05/tsinghua-photos/" itemprop="url">水清木华</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>七年时光，匆匆飞逝。入学之日还历历在目，离别之时却已悄然而来。我希望自己能挥一挥衣袖，不带走这里的一片云彩，但却留下自己青春的回忆。在这个偌大的园子里，有我的欢笑，有我的泪水，有我的努力。我相信所有清华学子在离别母校时，必定是依依不舍。但是，孩子总有离家之日，外面的舞台也必会更加精彩。</p>

<p>在毕业之际，载着园园骑车逛了一圈校园，再次好好地看了看这个生活了七年的地方，于是有了下面这一组照片。</p>

<p><img src="http://i758.photobucket.com/albums/xx224/onevcat/OneV-s-Den/tsinghua-photos/2012-05-16-095032-1.jpg" alt="清华园这三个字让多少人魂牵梦萦，而在这个园子里待了七年之后，我终将告别这里，踏上新的征途" /></p>


		
		<a href="/2012/05/tsinghua-photos/" class="more-link">继续阅读</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-05-10T00:00:00+09:00" data-updated="true" itemprop="datePublished">May 10<span>th</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/category/neng-gong-qiao-jiang-ji/'>能工巧匠集</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/2012/05/tools-for-color-picking/" itemprop="url">颜色选取和转换小工具</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><!--:zh--><p style="text-align: justify;"><a href="http://www.onevcat.com/wp-content/uploads/2012/05/2007106112356379_2.jpg"><img class="aligncenter size-full wp-image-741" title="2007106112356379_2" src="http://www.onevcat.com/wp-content/uploads/2012/05/2007106112356379_2.jpg" alt="" width="1024" height="256" data-pinit="registered" /></a></p>
<p style="text-align: justify;">iOS的app中，交互设计永远是重点中的重点，为用户界面选择合适的配色方法不仅对app整体美观有重要意义，同时也对用户体验的提升至关重要。但是在iOS开发中对于颜色的选取，转换和设定并不十分方便。通过配合使用下面的小工具可以提升颜色选取和转换的效率～</p>
<p style="text-align: justify;">1、颜色选择器</p>
<p style="text-align: justify;">         颜色选取不论在网页开发还是应用开发中都很常见。Mac虽然自带的颜色选择器，但是它并不单独存在，想要选取一个屏幕上的颜色，往往需要打开另外一些臃肿的应用。ColorPicker通过脚本做到只单独打开颜色选择器，从而快速地完成颜色选取工作。有关ColorPicker的详细信息可以参看<a href="http://www.robinwood.com/Catalog/Technical/OtherTuts/MacColorPicker/MacColorPicker.html#colorPickerApp">这里</a>，下载<a href="http://www.robinwood.com/Catalog/Technical/OtherTuts/MacColorPicker/ColorPicker.zip">这个zip包</a>，就可以将颜色选择器当做一个普通的Mac应用来使用了～</p>
<p style="text-align: justify;"><img class="size-full wp-image-742 aligncenter" title="tumblr_m3nr5xlftS1qd122y" src="http://www.onevcat.com/wp-content/uploads/2012/05/tumblr_m3nr5xlftS1qd122y.png" alt="" width="385" height="199" data-pinit="registered" /></p>
<p style="text-align: justify;">2、16进制颜色选择器</p>
<p style="text-align: justify;"><span style="text-align: justify;">        由于大部分时候需要使用代码控制颜色，因此需要知道选取的颜色的十六进制或者RGB表示，以方便代码使用。</span><a style="text-align: justify;" href="http://wafflesoftware.net/hexpicker/">这里</a><span style="text-align: justify;">提供了一个插件，可以在系统的颜色选择面板上显示当前颜色的十六进制编码，恰好满足了要求～</span></p>
<p style="text-align: justify;"><img class="size-full wp-image-743 aligncenter" title="tumblr_m3nrcq9O4p1qd122y" src="http://www.onevcat.com/wp-content/uploads/2012/05/tumblr_m3nrcq9O4p1qd122y.png" alt="" width="328" height="516" data-pinit="registered" /></p>
<p style="text-align: justify;">下载<a href="http://wafflesoftware.net/hexpicker/download/1.6.1/">这个zip包</a>，将包里的HexColorPicker.colorPicker解压到至文件夹 [homefolder]/Library/ColorPickers/ 下(如果不存在的话需要手动创建)即可。再打开系统的颜色选择器时，可以看到标签栏最右边多了一个#符号，点击即可看到当前颜色的十六进制值。</p>
<p style="text-align: justify;">3、还没结束呢..我们需要RGB/ColorPickers/文件夹下(如果不存在的话需要手动创建)即可。再打开系统的颜色选择器时，可以看到标签栏最右边多了一个#符号，点击即可看到当前颜色的十六进制值。</p>
<p style="text-align: justify;">据我所知，Cocoa里貌似没有直接通过颜色十六进制字串生成颜色对象的方法..所以可能还需要一点小转换。这个很简单，只是一个十六进制换算而已～</p></p>

<p><pre class="lang:objc decode:true ">UIColor* UIColorFromHex(NSInteger colorInHex) {
    // colorInHex should be value like 0xFFFFFF
    return [UIColor colorWithRed:((float) ((colorInHex &amp; 0xFF0000) &gt;&gt; 16)) / 0xFF
                           green:((float) ((colorInHex &amp; 0xFF00)   &gt;&gt; 8))  / 0xFF 
                            blue:((float)  (colorInHex &amp; 0xFF))            / 0xFF
                           alpha:1.0];
}</pre>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-04-22T00:00:00+09:00" data-updated="true" itemprop="datePublished">Apr 22<span>nd</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/category/neng-gong-qiao-jiang-ji/'>能工巧匠集</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/2012/04/objective-c-runtime/" itemprop="url">深入Objective-C的动态特性</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><!--:zh--><a href="http://www.onevcat.com/wp-content/uploads/2012/04/1295091_135049048284_2.jpg"><img class="aligncenter size-full wp-image-736" title="1295091_135049048284_2" src="http://www.onevcat.com/wp-content/uploads/2012/04/1295091_135049048284_2.jpg" alt="" width="1024" height="256" data-pinit="registered" /></a></p>

<p>Objective-C具有相当多的动态特性，基本的，也是经常被提到和用到的有动态类型（Dynamic typing），动态绑定（Dynamic binding）和动态加载（Dynamic loading）。</p>

<p>这些动态特性都是在Cocoa程序开发时非常常用的语言特性，而在这之后，OC在底层也提供了相当丰富的运行时的特性，比如枚举类属性方法、获取方法实现等等。虽然在平常的Cocoa开发中这些较底层的运行特性基本用不着，但是在某些情况下如果你知道这些特性并合理加以运用的话，往往能事半功倍～
<h3>动态特性基础</h3>
<h4>1、动态类型</h4>
即运行时再决定对象的类型。这类动态特性在日常应用中非常常见，简单说就是id类型。id类型即通用的对象类，任何对象都可以被id指针所指，而在实际使用中，往往使用introspection来确定该对象的实际所属类：</p>

<p><!--:-->
		
		<a href="/2012/04/objective-c-runtime/" class="more-link">继续阅读</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2012-04-04T00:00:00+09:00" data-updated="true" itemprop="datePublished">Apr 4<span>th</span>, 2012</time></div>
		<div class="tags">


	<a class='category' href='/category/bu-xing-chun-se-ji/'>不醒春色集</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/2012/04/spring-in-thu/" itemprop="url">难得的假期</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><!--:zh-->工作日到学校忙论文的事情，同时照顾着兼职开发，周末的时候到北语学日语。生活的忙碌看来将会一直持续一段时间了。难得迎来了一个月以来的唯一一天假期，早上很开心地睡到了快10点，然后借着马岛战争30年的契机，赖在床上和老婆一起把The Iron Lady补了..</p>

<p>但是所幸北京今天天气不错，于是下午到学校逛了一圈，抓了些花花草草的照片。北京春天的特点就是时间超短，而今年正好遇到嗓子不舒服，被夹杂了大量灰尘的春风这么一吹，回到家也半死不活的了…哎，什么时候才能稍微清闲一点呐…现在已经放弃了很多业余爱好了 T-T</p>

<p>注.开了一个新的集子——不醒春色集。该集取自最近很忙的杜甫大人的诗句“眼见客愁愁不醒，无赖春色到江亭”。这个集子将收的不仅是春天的东西，而是会收所有的吾之所见照片相关的内容。时值恰好冬去春来，万物复苏，而自己却又疲于杂事，日均益乏，故不醒于春色矣。</p>

<p>[simpleviewer gallery_id=&#8221;3&#8221;]<!--:--></p>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="/page/2/" class="prev">Prev</a>
    
    
        <a href="/page/4/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">全部文章</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner"><p>
	<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/80x15.png" /></a>本站点采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh">知识共享署名-非商业性使用 3.0 国际版本许可协议</a>进行许可
</p>
<p>
  2013 - <a href="http://about.me/onevcat">@onevcat</a>  
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'onevcat';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-25719337-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>




		</div>
	</div>
</body>
</html>
